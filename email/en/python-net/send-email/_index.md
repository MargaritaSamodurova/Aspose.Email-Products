---
title: Python send email. Send email using Python via .NET and SMTP protocol
url: /python-net/send-email/
description: How to send email with attachments using Python and Gmail, Outlook or other SMTP server
---

{{< blocks/products/pf/main-wrap-class >}}
{{< blocks/products/pf/upper-banner h1="Send email Python" h2="How to use Python and SMTP to send email with attachment or iCalendar" logoImageSrc="https://www.aspose.cloud/templates/aspose/img/products/email/headers/aspose_email-for-python-net.svg" pfName="Aspose.Email" subTitlepfName="for Python via .NET" downloadUrl="https://downloads.aspose.com/email/python-net" >}}

{{< blocks/products/pf/main-container pfName="Aspose.Email" subTitlepfName="for Python via .NET" >}}

{{< blocks/products/pf/sub-menu autoGeneratedVersion="true" logoImageSrc="https://www.aspose.cloud/templates/aspose/img/products/email/aspose_email-for-python-net.svg" codeSamplesLink="https://github.com/aspose-email/Aspose.Email-Python-Dotnet" buyLink="https://purchase.aspose.com/buy" docsLink="https://docs.aspose.com/email/python-net/" nugetLink="" nugetPackageName="" mavenRepoLink="" directDownloadLink="https://releases.aspose.com/email/pythonnet" >}}

{{% blocks/products/pf/agp/content h2="" %}}

As a rule, the SMTP protocol is used to send email messages. You need access to an SMTP server in order to send a message. You need to find the address of the SMTP server on the network, determine the port and type of encryption, login and authorization method. Some email providers also require you to enable access to the SMTP server in your account settings. Also, if you are not comfortable implementing OAuth authorization in your software, you can try creating a separate password for the application in your account settings.

So, if you have done all the preparatory work, it's time to start sending messages. You can use the Aspose.Email for Python via .NET library for this. Consider the simplest example:

```python
smtpClient = SmtpClient('smtp.gmail.com', 465, 'login', 'password', SecurityOptions.SSL_AUTO)
smtpClient.send('login@gmail.com', 'to@gmail.com', 'subject', 'body')
```

Use this option if you want to send a simple text email.

{{% /blocks/products/pf/agp/content %}}

{{% blocks/products/pf/feature-page-section  h2="Send email with attachments using Python" %}}

If you need to send a complex email message using Python, the MailMessage class will definitely come in handy. For example, to send a message similar to the previous one:

```python
message = MailMessage('login@gmail.com', 'to@aspose.com', 'subject', 'body')
smtpClient.send(message)
```
The MailMessage class is a great tool. It allows you to send messages stored in EML and MSG (Outlook Message Format) file formats. You can also use this format to send attachments or even iCalendar objects to set up or confirm attendance. MailMessage allows you to fine-tune your list of recipients, Cc and Bcc recipients. You can send an email with HTML markup. You can also mark the message with various flags before sending it, add metadata, encrypt it, etc.

{{% /blocks/products/pf/feature-page-section %}}

{{% blocks/products/pf/feature-page-section  h2="Why do people choose Aspose.Email for Python via .NET for sending email?" %}}

Yes, Aspose.Email for Python via .NET is not just a utility for sending email messages. This is a comprehensive solution that provides comprehensive support for a variety of tasks related to sending, receiving, storing, and processing email. And you can be sure that when performing these tasks, you will not run into the limitations of the library. We have been studying this topic for many years and are constantly expanding its functionality.

You have probably come across small libraries that have appeared relatively recently. They easily and naturally solve a simple problem that many users face. But as soon as you step aside a little, you realize that by continuing to use this unpretentious one, you are forced to constantly fence crutches, some modules to bypass library restrictions, adapters designed to make friends with your small library with another small library, etc. And now, your little nifty solution isn't so nifty anymore. Moreover, you send it to the server, where it regularly and consistently shoots itself in the foot, because no one has tested such a zoo of crutches and integrations before you. And no matter how hard you try, sooner or later you will still run into the limitations of this library. And you have to look for something new. So, when it comes to working with email, you might want to consider Aspose.Email for Python via .NET!

We offer you not just a client for working with SMTP. First, it's far from the only protocol for sending emails with Python. With our product, you can send emails using Exchange EWS and Microsoft Graph!

We have already told you about the possibilities of MailMessage in this article. But this is far from the only tool for preparing letters for sending. You can:
- generate letters from a template using TemplateEngine;
- unpack containers with letters, thanks to the support of OST, PST, and MBOX formats;
- download letters from the mailbox using the support of IMAP, POP3, Exchange EWS, and WebDav protocols, as well as Microsoft Graph;
- convert emails from one format to another.

You can easily receive a letter using the Exchange Ews protocol. It will be in MAPI format. But you can easily convert it to EML format, which will allow you to send it later via SMTP protocol. At the same time, you can change the list of recipients or the letter's sender at any time.

{{% /blocks/products/pf/feature-page-section %}}

{{% blocks/products/pf/feature-page-section  h2="How does sending an email using Python and SMTP work?" %}}

### SMTP Configuration

The moment you create an instance of the SmtpClient class, nothing special happens. You simply specify the number of settings that will allow you to connect to an SMTP server in the future to send messages. All the magic happens on the first call to the ```send``` method. What is happening at this moment?

In fact, it all depends on what settings you have specified. Let's consider several options. Let's say that you have specified the server host but have not specified the port and encryption type. In this case, the mechanism of automatic selection of settings will start. This mechanism consists of successive attempts to connect to the SMTP server using standard ports and the corresponding encryption algorithms. First, an attempt is made to connect to the server over an encrypted channel. But if it fails, the mechanism will try to establish an unencrypted connection. If you do not want to use the non-encrypted version of the protocol, specify the ```SecurityOptions.SSL_AUTO``` setting. This setting also allows you to select server settings, but only checks encrypted channels.

If it was possible to establish a connection with the server, then an authorization attempt is made. If authorization fails, the error code is saved for the future. The matcher will try to connect in other ways. The message will be sent if you can connect and login. If the connection fails, the user will receive an authorization error code (if one was saved during the selection). So the user will be able to understand that he entered the wrong password or made some other mistake. If none of the options for ports and encryption types fit and we didn't even get to the authorization attempt, the user will receive an error notifying about incorrect server settings.

By the way, it should be noted that our SmtpClient (like all other clients of our library) can connect to the SMTP server through a proxy. You can also specify proxy server settings during initialization.

### SMTP client authorization

SmtpClient supports more than just different connection methods. It also supports different authorization methods. For example, you can use the OAuth mechanism. To do this, we provide several tools at once.

First of all, it is TokenProvider. This is the class that contains all the necessary data to store and refresh the OAuth token. In this case, you must perform the OAuth authorization yourself and save all the necessary information received from the OAuth server. RefreshToken plays a key role here. This is an additional token issued by the authorization server, along with AccessToken. Their difference is that AccessToken, as a rule, is valid only for a certain period of time. Whereas RefreshToken is valid for much longer, or even indefinitely (until the user revokes it). Thanks to RefreshToken, the TokenProvider class can always refresh an AccessToken if the latter is no longer valid.

Another option is the ITokenProvider interface. In this case, you can not only implement the OAuth mechanism yourself but also pass it to the SmtpClient so that it uses it itself as needed.

It should be noted that the OAuth mechanism is not always necessary. Sometimes it is much easier to log in with a username and password. And for this, you do not need to reconfigure your email account at all, refuse two-factor authorization, etc. There is a more secure solution - this is a separate password for the application. To take advantage of this feature, you should look into your email account settings. Most likely, the password for the application will be generated automatically when you set it up in your account. Don't forget to save it somewhere. We also recommend limiting your application's permissions as much as possible during configuration. Of course, if an attacker gains access to this password, he will not be able to appropriate your account, but he can still do a lot of unpleasant things. And here you canâ€™t do anything, because the password is the only thing that protects your data from intruders. In general, the tool is very convenient, but lowers the security of your account, use it at your own risk.

### Sending email via SMTP with Python

So, the connection to the server is established, and the authorization was successful. It's time to send letters. For sending, an object of the MailMessage class is used. Technically, you can just pass all the necessary data to the send method. But, in fact, they will still be collected in the MailMessage object. Further, thanks to the ability of the MailMessage class to serialize to the EML format, we get the necessary data stream that can be passed to our SMTP server. Thus, we give the server a command to send a letter and transfer all the contents of the letter to it in the form of text data. If binary data is transmitted in the letter, for example, in the form of attached files, this data is encoded in Base64 format, and the metadata of the letter indicates that the recipient will need to decode it back. The SMTP server can check the correctness of the received message (for example, check the FROM field with the sender's account on the server), as well as supplement the metadata of the message at its discretion. Then, the server will send the email to the recipients, a list of which it will also get from the email's metadata.

{{% /blocks/products/pf/feature-page-section %}}

{{< /blocks/products/pf/main-container >}}

{{< /blocks/products/pf/main-wrap-class >}}